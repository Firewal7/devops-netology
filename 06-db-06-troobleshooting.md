## Домашнее задание к занятию 6. «Troubleshooting»

### Задача 1

Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD-операция в MongoDB и её нужно прервать.

Вы как инженер поддержки решили произвести эту операцию:

- напишите список операций, которые вы будете производить для остановки запроса пользователя;


### Ответ

Определение текущей операци: [db.currentOp()](https://www.mongodb.com/docs/manual/reference/method/db.currentOp/)

Завершение операции по opid: [db.killOp()](https://www.mongodb.com/docs/manual/tutorial/terminate-running-operations/#killop) 

- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB.
  
Метод [maxTimeMS()](https://www.mongodb.com/docs/manual/tutorial/terminate-running-operations/#maxtimems)  устанавливает ограничение по времени для операции. Когда операция достигает указанного срока, MongoDB прерывает операцию.

### Задача 2

Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причём отношение количества записанных key-value-значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:

сначала происходит рост отношения записанных значений к истекшим,
Redis блокирует операции записи.
Как вы думаете, в чём может быть проблема?

- многие ключи, срок действия которых истекает в один и тот же момент, могут быть источником задержки. Если в базе данных много ключей, срок действия которых истекает в одну и ту же секунду, и они составляют не менее 25% текущей совокупности ключей с установленным сроком действия, Redis может заблокировать, чтобы получить процент ключей, срок действия которых уже истек. ниже 25%.

- возможно из-за нехватки памяти.
### Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей в таблицах базы пользователи начали жаловаться на ошибки вида:

InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения этой проблемы вы можете предложить?
```
Увеличить значение параметров: interactive_timeout, wait_timeout, connect_timeout.
При возникновении сетевых сбоев увеличить значение net_read_timeout.
```
### Задача 4

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объёмом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

postmaster invoked oom-killer

Как вы думаете, что происходит?
```
Это указывает на то, что процесс postgres был остановлен из-за нехватки памяти.
Для восстановления PostgreSQL потребуется перезапустить.
```

Как бы вы решили эту проблему?

```
Добавить машине достаточное количество памяти, если памяти мало, увеличить пространство подкачки операционной системы.

Если сам PostgreSQL является причиной нехватки памяти в системе, вы можете избежать этой проблемы, изменив конфигурацию.
```

Если памяти не хватает по вине самого PostgreSQL, эту проблему можно решить, изменив конфигурацию сервера. В некоторых случаях может помочь уменьшение конфигурационных параметров, связанных с памятью, а именно:  

- [shared_buffers](https://postgrespro.ru/docs/postgresql/15/runtime-config-resource#GUC-SHARED-BUFFERS)

Задаёт объём памяти, который будет использовать сервер баз данных для буферов в разделяемой памяти. Если вы используете выделенный сервер с объёмом ОЗУ 1 ГБ и более, разумным начальным значением shared_buffers будет 25% от объёма памяти. 

- [work_mem](https://postgrespro.ru/docs/postgresql/15/runtime-config-resource#GUC-WORK-MEM)

Задаёт базовый максимальный объём памяти, который будет использоваться во внутренних операциях при обработке запросов (например, для сортировки или хеш-таблиц), прежде чем будут задействованы временные файлы на диске. 

- [hash_mem_multiplier](https://postgrespro.ru/docs/postgresql/15/runtime-config-resource#GUC-HASH-MEM-MULTIPLIER)

Используется для определения максимального объёма памяти, который может выделяться для операций с хешированием.
Значение hash_mem_multiplier имеет смысл увеличить, когда постоянно наблюдается вытеснение данных на диск при выполнении запросов, а прямолинейное увеличение work_mem приводит к дефициту памяти (обычно проявляющемуся в ошибках «нехватка памяти»).
